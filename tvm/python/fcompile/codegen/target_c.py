from .base import BaseCodeGen, OpType, np2bytes
from .function import *
from time import strftime, localtime


class Malloc:

    def static(self, name, dtype, attrs):
        self.var = "static " + dtype + " " + name + ";"
        if dtype == OpType.f_ddr:
            return self.f_ddr(name, attrs)
        elif dtype == OpType.w_ddr:
            return self.w_ddr(name, attrs)
        elif dtype == OpType.const:
            return self.const(name, attrs)
        elif dtype == OpType.c_ptr:
            return self.c_ptr(name, attrs)

    def f_ddr(self, name, attrs):
        init = MallocFeature(name, attrs, prefix=0)
        return self.var, init

    def w_ddr(self, name, attrs):
        init = MallocWeight(name, attrs, prefix=0)
        return self.var, init

    def const(self, name, attrs):
        params = f"{name} = ({OpType.c_ptr})params; params += {attrs[0]};"
        return self.var, params

    def c_ptr(self, name, attrs):
        init = f"{name} = ({OpType.c_ptr})malloc({attrs[0]});"
        return self.var, init


class CCodeGen(BaseCodeGen):

    tab = "  "

    def build(self, jit, prefix="TVMWrap", debug=True):
        self.debug = debug
        self.analysis(jit)
        params = b"".join([np2bytes(data) for data in self.datas])
        return self.get_source(prefix), params, self.extern

    def analysis(self, jit):
        self.static = []
        self.inits  = []
        self.params = []
        self.inputs = []
        self.outputs = []
        self.funcops = []
        self.datas = []
        self.extern = []

        if self.debug:
            ops = [
                "struct timespec begin, end;",
                "long seconds, nanoseconds;",
                "double elapsed;",
            ]
            self.funcops.append("\n".join([self.tab + op for op in ops]))

        for node in jit:
            self.node_type = node["node_type"]
            self.node_ret = node["return"]
            if self.node_type == "var":
                self.inputs.append(node["return"])
            elif self.node_type == "output":
                self.outputs.append(node["return"])
            for key, value in node.items():
                self.gen(key, value)

    def gen_static(self, value):
        name, dtype, attrs = value["name"], value["type"], value["attrs"]
        var, init = Malloc().static(name, dtype, attrs)
        self.static.append(var)
        if self.node_type == "const":
            self.params.append(init)
        else:
            self.inits.append(init)

    def gen_params(self, value):
        self.params += value

    def gen_callop(self, value):
        ops = value
        if self.debug:
            name = self.node_ret["name"]
            ops = ["clock_gettime(CLOCK_REALTIME, &begin);"] + ops
            ops += ["clock_gettime(CLOCK_REALTIME, &end);"]
            ops += ["seconds = end.tv_sec - begin.tv_sec;"]
            ops += ["nanoseconds = end.tv_nsec - begin.tv_nsec;"]
            ops += ["elapsed = seconds + nanoseconds*1e-9;"]
            ops += [f"printf(\"Finish {name} op takes: %fs\\n\\n\", elapsed);"]
        self.funcops.append("\n".join([self.tab + op for op in ops]))

    def gen_data(self, value):
        self.datas.append(value[1])

    def gen_extern(self, value):
        self.static.append(value[0])
        self.extern.append(value[1])

    def get_source(self, prefix):
        local_time = strftime('%Y-%m-%d %H:%M:%S',localtime())
        static = "\n".join(self.static)
        init = "\n".join([self.tab + s for s in self.inits])
        params = "\n".join([self.tab + s for s in self.params])
        input_cmt = "\n".join([f"// input {n}: " + shape2str(i["shape"])
                               for n, i in enumerate(self.inputs)])
        input_len = len(self.inputs)
        input_ptr = ", ".join(["(uintptr_t)" + i["name"] for i in self.inputs])
        output_cmt = "\n".join([f"// output {n}: " + shape2str(i["shape"])
                               for n, i in enumerate(self.outputs)])
        output_len = len(self.outputs)
        output_ptr = ", ".join(["(uintptr_t)" + i["name"] for i in self.outputs])
        funcops = "\n\n".join(self.funcops)

        source_map = {
            "local_time" : local_time, "prefix" : prefix, "static" : static, 
            "params" : params, "input_cmt" : input_cmt, "input_len" : input_len,
            "input_ptr" : input_ptr, "output_cmt" : output_cmt, "output_len" : output_len,
            "output_ptr" : output_ptr, "funcops" : funcops, "init" : init,
        } 

        source = """// generated by fcompile.codegen.CCodeGen at %(local_time)s
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

#include <faccel.h>

%(static)s

void %(prefix)sInit() {
%(init)s
}

void %(prefix)sSetParams(char* params) {
%(params)s
}

%(input_cmt)s
void* %(prefix)sGetInputPtr(int index) {
  uintptr_t array_ptr[%(input_len)d] = { %(input_ptr)s };
  return (void*)array_ptr[index];
}

%(output_cmt)s
void* %(prefix)sGetOutputPtr(int index) {
  uintptr_t array_ptr[%(output_len)s] = { %(output_ptr)s };
  return (void*)array_ptr[index];
}

void %(prefix)sRun() {
%(funcops)s
}""" % source_map
        return source
