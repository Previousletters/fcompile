from time import strftime, localtime

# generate static jit model
class CodeGen:

    def __init__(self, model):
        self.model = model

    def gen_head_static(self, model_name, tab="  "):
        local_time = strftime('%Y-%m-%d %H:%M:%S', localtime())
        in_payload = []
        for key, value in self.model["inputs"].items():
            in_payload.append(f"int {key}_payload = {value[0]};")
            in_payload.append(f"int {key}_payload_size = {value[1]};")
        in_payload_str = "\n".join(in_payload)
        out_payload = []
        for key, value in self.model["output"].items():
            out_payload.append(f"int {key}_payload = {value[0]};")
            out_payload.append(f"int {key}_payload_size = {value[1]};")
        out_payload_str = "\n".join(out_payload)
        run_model = [f"void {model_name}(HANDLE device) " + "{"]
        run_body = []
        for key, value in self.model["regops"].items():
            run_model.append(tab + key + "(device);")
            run_body_tp = [f"void {key}(HANDLE device) " + "{"]
            for csb in value:
                run_body_tp_src = tab
                if csb[0]:
                    run_body_tp_src += f"CSB_Write(device, {csb[1]}, {csb[2]});"
                else:
                    run_body_tp_src += f"while (CSB_Read(device, {csb[1]}) != {csb[2]}) " + "{ }"
                run_body_tp.append(run_body_tp_src)
            run_body_tp.append("}")
            run_body.append("\n".join(run_body_tp))
        run_model.append("}")
        run_body_src = "\n".join(run_body)
        run_model_src = "\n".join(run_model)
        source_map = {
            "local_time" : local_time, "inputs_str" : in_payload_str, "output_str" : out_payload_str,
            "model_name" : model_name, "run_body_src" : run_body_src, "run_model_src" : run_model_src,
        }
        source = '''// generated by python at %(local_time)s
// inputs payload and payload_size
%(inputs_str)s

// output payload and payload_size
%(output_str)s

// \"%(model_name)s\" layer wrapper function
%(run_body_src)s

// \"%(model_name)s\" model wrapper function
%(run_model_src)s
''' % source_map
        return source

    def gen_head(self, model_name, tab="  "):
        local_time = strftime('%Y-%m-%d %H:%M:%S', localtime())
        in_payload = []
        for key, value in self.model["inputs"].items():
            in_payload.append(f"unsigned long long {key}_payload = {value[0]};")
            in_payload.append(f"unsigned long long {key}_payload_size = {value[1]};")
        in_payload_str = "\n".join(in_payload)
        out_payload = []
        for key, value in self.model["output"].items():
            out_payload.append(f"unsigned long long {key}_payload = {value[0]};")
            out_payload.append(f"unsigned long long {key}_payload_size = {value[1]};")
        out_payload_str = "\n".join(out_payload)
        attr_str = ", ".join([f"int {attr}" for attr in self.model["attrs"]])
        if len(attr_str) > 0:
            attr_str = ", " + attr_str
        run_model = [f"void {model_name}(HANDLE device{attr_str}) " + "{"]
        run_body = []
        for key, value in self.model["regops"].items():
            attr_str = ", ".join([f"int {attr}" for attr in self.model["attrs"]])
            call_str = ", ".join(self.model["attrs"])
            if len(attr_str) > 0 and len(call_str) > 0:
                attr_str = ", " + attr_str
                call_str = ", " + call_str
            run_model.append(tab + key + f"(device{call_str});")
            run_body_tp = [f"void {key}(HANDLE device{attr_str}) " + "{"]
            tab_block = 1
            for csb in value["body"]:
                run_body_tp_src = ""
                if csb[0] == -1:
                    tab_block -= 1
                for i in range(tab_block):
                    run_body_tp_src += tab
                if csb[0] == 1:
                    run_body_tp_src += f"CSB_Write(device, {csb[1]}, {csb[2]});"
                elif csb[0] == 0:
                    run_body_tp_src += f"while (CSB_Read(device, {csb[1]}) != {csb[2]}) " + "{ }"
                elif csb[0] == -1:
                    run_body_tp_src += "}"
                else:
                    run_body_tp_src += f"for (int {csb[0]} = {csb[1]}; {csb[0]} < {csb[2]}; {csb[0]}++) " + "{"
                    tab_block += 1
                run_body_tp.append(run_body_tp_src)
            run_body_tp.append("}")
            run_body.append("\n".join(run_body_tp))
        run_model.append("}")
        run_body_src = "\n".join(run_body)
        run_model_src = "\n".join(run_model)
        source_map = {
            "local_time" : local_time, "inputs_str" : in_payload_str, "output_str" : out_payload_str,
            "model_name" : model_name, "run_body_src" : run_body_src, "run_model_src" : run_model_src,
        }
        source = '''// generated by python at %(local_time)s
// inputs payload and payload_size
%(inputs_str)s

// output payload and payload_size
%(output_str)s

// \"%(model_name)s\" layer wrapper function
%(run_body_src)s

// \"%(model_name)s\" model wrapper function
%(run_model_src)s
''' % source_map
        return source
